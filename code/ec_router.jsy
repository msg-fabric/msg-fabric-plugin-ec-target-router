import {URL} from 'url'
import {createECDH, createHmac} from 'crypto'
import createPacketParser from 'msg-fabric-packet-stream'

export default function ec_router_plugin(plugin_options={}) ::
  return @: order: -2, subclass

  function subclass(FabricHub_PI, bases) ::
    Object.assign @ FabricHub_PI.prototype, @:
      packetParser: createPacketParser @ plugin_options
      _parseConnectURL(conn_url) :: return new URL(conn_url)
      _init_router() :: return new ECRouter()

    class ECRouter extends bases.Router ::
      constructor() ::
        super()
        initRouterIdentity(this, plugin_options.ec_curve, plugin_options.ec_pem)


ec_router_plugin.initRouterIdentity = initRouterIdentity
function initRouterIdentity(router, curve, ec_pem) ::
  // Create closures over the Router's EC private identity credentials
  var __ec_priv_id__, ec_pub_id, id_self
  if ! curve :: curve = 'prime256v1'
  while ! id_self :: // ensure id_self !== 0 by happenstance
    __ec_priv_id__ = Object.assign @ createECDH(curve), @{} curve
    ec_pub_id = __ec_priv_id__.generateKeys(null, 'compressed')
    id_self = ec_pub_id.readUInt32LE(8) // read id from offset 8 to 12

  Object.defineProperties @ router, @:
    id_self: @: value: id_self
    ec_pub_id: @: value: ec_pub_id
    ec_id_hmac: @: value: ec_id_hmac


  if undefined === ec_pem ::
    const ec_pem_missing = @: value() ::
      throw new Error @ `Requires optional [ec-pem][1] dependency.\n    [1]: https://www.npmjs.com/package/ec-pem`

    Object.defineProperties @ router, @: ec_id_sign: ec_pem_missing, ec_id_verify: ec_pem_missing

  else ::
    const ec_signed_id = ec_id_sign('sha256', ec_pub_id).sign()
    if ! ec_signed_id_verify(ec_pub_id, ec_signed_id) ::
      throw new Error @ `Asserted self-verify of ec_pub_id failed`

    Object.defineProperties @ router, @:
      ec_signed_id: @: value: ec_signed_id
      ec_id_sign: @: value: ec_id_sign
      ec_id_verify: @: value: ec_id_verify



  function ec_id_hmac(ec_pub_other, reverse) ::
    const secret = __ec_priv_id__.computeSecret(ec_pub_other)
    return createHmac('sha256', secret)
      .update @ reverse ? ec_pub_other : ec_pub_id
      .digest()

  function ec_id_sign(algorithm, ...args) ::
    return ec_pem.sign(__ec_priv_id__, algorithm, ...args)

  function ec_signed_id_verify(ec_pub_other, ec_signed_other) ::
    const verify = ec_id_verify(ec_pub_other, 'sha256', ec_pub_other)
    return ec_signed_other ? verify.verify(ec_signed_other) : verify

  function ec_id_verify(ec_pub_other, algorithm, ...args) ::
    // see ec-pem.verfiy and crypto.createVerfiy
    let ec = ec_pub_other
    if null == ec_pub_other.curve ::
      ec = Object.assign @ createECDH(curve), @{} curve
      if ec_pub_other.getPublicKey ::
        ec.setPublicKey @ ec_pub_other.getPublicKey()
      else ec.setPublicKey @ ec_pub_other

    return ec_pem.verify(ec, algorithm, ...args)

